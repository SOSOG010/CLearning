字符处理函数

toupper函数：在被调用时检测参数（字符类型）是否是小写字母。如果是，会把参数转换成相应的大写字母；否则，会返回参数的值。

C语言中函数不一定要有参数，也不一定要计算数值。（在某些编程语言中，“函数”返回一个值，而“过程”不返回值，C语言没有这样的区别）

函数可以复用，每个函数本质上是一个自带声明和语句的小程序。

# 函数定义

```
返回类型	函数名(形式参数列表){
		声明
		语句
}
```

函数不能返回数组，但关于返回类型没有其他限制。

返回类型是void说明没有返回值。

如果省略返回类型，C89会假定函数返回值的类型是int类型，但在C99中这是非法操作。

ps：如果返回类型冗长，如unsigned long int类型，可以把返回类型单独放在一行。

形参列表：必须在每个形式参数前说明类型，即使类型是相同的。形参之间用逗号隔开。如果函数没有形式参数，应在形参列表中写上void。

函数体内声明的变量专属此函数，其他函数不能访问这些变量。在C89中变量声明必须出现在语句之前，在C99中可以在语句中使用变量时声明（如for循环语句中声明某一变量），只要在第一次使用前声明就行。

### 空函数

对于返回类型为void的函数可以称为空函数。其函数体可以为空：

``` C
void func(void){
    
}
```

作用：可以在没来得及写某个函数时为该函数预留空间，方便以后再写。

# 函数调用

函数调用必须带上括号（即使参数列表为空）。如getchar()

非void函数调用会产生一个值，该值可以存储在变量中，也可以进行测试、显示或其他用途。如果没有用变量存储则会自动丢弃该值。

为了更明确地表示函数返回值是被故意丢弃的，C语言允许在函数调用前加上(void)：(void)getchar()——即把函数的返回值类型强制转换成void。但不推荐这样做。



不同函数中的变量可以重名。这些变量在内存中的地址不同，对其中一个变量的操作不会影响其他变量。

一个函数可以有多条return语句，但在任何一次函数调用中只能执行其中的一条return语句，因为执行return语句后函数就会回到调用点。

# 函数声明（function declaration）

如果函数的定义放在调用点的后面。就需要提前声明该函数，告知编译器该函数的基本信息。

这些基本信息也叫函数原型（function prototype）包括：返回类型、函数名以及形参列表。

ps：函数原型不需要说明函数形式参数的名字，只用显示类型就行，但是在实际编程中通常也把参数名写上，说明每个形参的目的并提示调用时实参的顺序。进而增加程序的可读性。

# 实际参数与形式参数

C语言中，实际参数是通过值传递的：调用函数时，计算每个实际参数的值并把它赋给相应的形式参数。可以理解为用实参的值来初试化对应的形参。

因此，在函数执行过程中，对形参的改变不会影响实参的值。

值传递的优点：可以将形参作为函数内的变量使用，减少真正需要的变量的数量。

缺点：对于某些需要改变实参值的函数不适用。

## 实参的转换

C语言允许在实参的类型与形参的类型不匹配的情况下进行函数调用。

- 编译器在调用函数前遇到函数原型：自动转换成函数原型中对应形参类型
- 编译器在调用函数前没有遇到函数原型：执行默认实参提升：①float升为double。②char/short升为int

注：最好避免类型的不匹配问题。

## 数组型参数

数组经常被用作实际参数。作为实参传入时不用加[ ]，只用写数组名。如：Initialize（a，10）

当形参是一维数组时，可以（且通常情况）不说明数组的长度：

```C
int func(int a[]){
    
}
int func(int a[], int length){
	
}
```

C语言没有为函数提供任何简单的方法来确定传递给它的数组的长度，如果函数需要，还必须把长度作为额外的参数提供。

> 注：虽然可以用sizeof计算出数组变量的长度，但无法给出关于数组型形式参数的正确答案。

```c
int func(int a[]){
    int len = sizeof(a)/sizeof(a[0]);
    /**WRONG: not the number of elements in a**/
}
```

在函数原型中，即函数声明时，也可以将形参数组的数组名省略，但同样不推荐这样做。

> **注意：函数对数组型形式参数的改变会在对应的实际参数中体现出来。（因为事实上数组作为形式参数时就退化成了指针）**

```c
//初始化数组
void Initialize(int a[],int n){
	for(int i = 0; i < n; i++)
		a[i] = 0;
}
```

> 总结：事实上，可以通过使用指针数组的方式来将数组作为函数的参数传递，这种方式支持多维数组，更加优秀。

## 变长数组形式参数

C99的新特性中加入了变长数组的特性，允许用变量指定数组的长度。且变长数组也可作为参数。

对于一维变长数组可以使用如下方法：

```c
//这种方法传入的n和数组a的长度之间没有直接的联系
int sum_array(int a[], int n){
	
}
//这种方法可以明确说明数组a的长度就是n，但注意参数的顺序
//编译器要先知道变量n，才能识别a[n]
int sum_array(int n, int a[n]){

}
```

对于二维变长数组：

```c
//二维数组求和，同样注意参数的顺序。
int sum_two_dimensional_array(int n, int m, int a[n][m]){
	int i,j,sum = 0;
	for(i = 0; i < n; i++)
		for(j = 0; j < m; j++)
			sum += a[i][j];
	return sum;
}
```



# 程序终止

程序的入口是main函数，程序的终止也是main函数的终止。正常情况下main函数的返回类型是int类型，以往的C程序常常省略main函数的返回类型，这其实是利用了返回类型默认是int型的传统。但省略函数返回类型在C99中是非法的！

注：省略main函数的参数列表中的void是合法的，但从编程风格的角度看，最好显式地表明main函数没有参数。（其实main函数有时是有两个参数的，通常名为argc和argv）

main函数返回的值是状态码，在某些操作系统中程序终止时可以检测到状态码。如果程序正常终止，main函数应该返回0；为了表示异常终止，main函数应该返回非0的值。

## exit函数

在main函数中执行return语句是终止程序的一种方法，另一种方法是调用exit函数，该函数属于<stdlib.h>头。传递给exit函数的实际参数和main函数的返回值具有相同的含义：两者都说明程序终止时的状态。

```c
exit(0);	/* normal termination 正常终止*/
exit(EXIT_SUCCESS);		/* 更精确的正常终止 */
exit(EXIT_FALLURE);		/* abnormal termination */
```

EXIT_SUCCESS和EXIT_FALLURE都是定义在<stdlib.h>中的宏。值通常分别为0和1。

return语句和exit函数之间的差异是：在任何函数中调用exit函数都会导致程序终止，只有在main函数中调用return语句才会导致程序的终止。



# 递归（recursive）——函数调用本身

函数只调用自身一次

```C
//计算乘方
int power(int x, int n){
    return n == 0 ? 1 : x*power(x, n-1);
}

//阶乘
int fact(int n){
    return n <= 1 ? 1 : n*fact(n-1);
}
```

函数调用自身两次

```c
//斐波拉切函数
int Fib(int n){
	if(n == 0)
		return 1;
	else if(n == 1)
		return 2;
	else
		return Fib(n-1) + Fib(n-2);
}
//快速排序

```





# 编程题

输入一串整数（把这串整数存储在数组中），然后通过调用函数来排序。

- 搜索数组找出最大元素，然后把它移到数组的最后；
- 递归地调用函数本身来对前n-1个数组元素排序。



幂函数的优化

```c
int power(int x, int n){
    if(n==0)
        return 1;
    else
        return n%2 == 0 ? power(power(x,n/2),2) : x*power(x,n-1);
}
```



编写函数计算多项式。
$$
3x^5+2x^4-5x^3-x^2+7x-6
$$
