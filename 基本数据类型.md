# 整型

整型一般可以分为短整型（short）、整型（int）和长整型（long long），其中short一般用不到。在就算计内部整型是以补码的形式表示。

- 整型int。一个整数占用32bit，取指范围是 -2^31^~2^31^-1 。可以简单的记为绝对值在10^9^范围以内的整数都可以用int型定义。——输出格式%d

- 长整型long long。一个整数占用64bit，取值范围是  -2^63^~2^63^-1。可以简单的记为绝对值范围在10^10^~10^18^内。——输出格式%lld（C99中新增）

  > 注：给长整型赋大于2^31^-1的初值时要在数字后面加上LL，否则会编译错误。

除此之外，对于整型数据，还可以在前面加个unsigned，以表示无符号整型，unsigned int 范围：0~2^32^-1 ；unsigned long long 范围：0~2^64^-1 。一般很少用无符号整型。

> 整型常量：十进制：无前缀；八进制：前缀0，输入输出格式%o；十六进制前缀0x，输入输出格式%x。长整型后缀L、LL，输入输出格式%ld、%lld；无符号后缀U，输入输出格式%u。
>
> 注：%o和%x分别用于八进制和十六进制无符号整数。如果是有符号整数，整数是一样的，没问题。负数需要判断
>
> ```c
> if(i < 0)
> 	printf("-%x",-i);
> else
> 	printf("%x",i);
> ```
>
> 

# 浮点型

浮点数在计算机内部是以IEEE754标准存储，分为尾数和阶数。

浮点型可以分为单精度float和双精度double

- float：一个浮点数占用32bit，其中1bit作为符号位、8bit作为指数位、23bit作为尾数位，范围是 -2^128^~2^128^但其有效精度只有6~7位。——读书和输出格式%f
- double：一个浮点数占用64bit，其中1bit作为符号位、11bit作为指数位、52bit作为尾数位，范围是 -2^1024^~2^1024^，其有效精度有15~16位。——读入格式%lf，输出格式%f

> 注：对于浮点型来说，不要使用float，碰到浮点型的数据都应该用double来存储。



# 字符型

字符变量和字符常量——输出格式%c

C语言中，字符常量使用ASCII码统一编码。标准ASCII码的范围是0~127，其中包含了控制字符或通信专用字符（不可显示）和常用的可显示字符。常见的有 “0--9：48--57、A--Z：65--90、a--z：97--122” ，**记住数字ASCII码比实际数值大48，小写字母ASCII码比大写字母大32。**

字符常量必须以单引号括起来。在计算机内部，字符是按ASCII码值存储的，因此char类型在某种意义上可以说是一种整型，也可以转换为int型。

### 字符读写getchar和putchar

- getchar函数返回的是一个int类型的值，而不是char类型的值。

- getchar函数在读取时不会跳过空白字符（这点和scanf一样）。

- getchar函数和putchar函数执行速度快，由于scanf和printf。

- 可以使用getchar来暂停程序的运行，回车后继续运行。

- getchar可以应用在多种不同的C语言惯用法中，包括“搜索字符”和“跳过所有出现的同一字符的循环中”

  ```CQL
  while(getchar() != '\n')	//跳过输入行的剩余部分，即回车后输入结束
  
  while(getchar() == ' ')		//跳过空格，即遇到第一个非空白字符时循环终止
  
  //确定消息的字符数
  #include<stdio.h>
  int main(){
  	int len = 0,ch;
      while((ch = getchar()) != '\n'){
      	if(ch != ' ')
      		len++;
      }
      printf("%d\n",len);
      return 0;
  }
  ```

  在同一个程序中混合使用getchar和scanf要注意。scanf会遗留未读取的字符（比如换行符），这时候getchar会先读取scanf遗留的字符。



字符串常量——输出格式%s

字符串是由若干字符组成的串，在C语言中没有单独一种基本数据类型可以存储字符串（C++中有string类型），**只能使用字符数组的方式。**

字符串常量是由双引号标记的字符集。**字符串常量可以作为初值赋给字符数组。**

> 注：不能把字符串常量赋值给字符变量，这样是非法的。
>



# 布尔类型

布尔型在C++中可以直接使用，但在C语言中必须添加stdbool.h头文件才可以使用。取值只能是ture或false，分别代表非零与零。

在赋值时，可以直接使用true或false赋值，也可以使用整型常量赋值，只不过整型常量在赋值给布尔型常量时会自动转换为true（非零值）或false（零）。反过来，如果使用%d输出bool型变量，则true和false对应输出1和0。



# 强制类型转换

在C语言编程中，强制类型转换很简洁，只要把需要变成的类型用括号括着写在前面就行了。格式如下：

（新类型名）变量名

如果赋值时没有写强制类型转换，编译器会自动转换，但是如果在计算过程中需要转换类型，就不能自动转换。

### 强转在计算机内部的具体实现

强转的结果保持机器数位值不变，仅改变了解释这些位的方式。

**1、有符号整数和无符号整数的转换**

无符号数unsigned解释为二进制真值X，有符号数解释为补码[X]~补~。

- 有符号数——>机器数——>无符号数：

  - 有符号数的机器数采用补码表示，因此，先将数值写为原码，然后原码转为补码（符号位不变，其余位取反末位加1），该补码就是有符号数在计算机内部的存储机器数。

  - 再将该机器数解释为无符号数（即二进制真值）

- 无符号数——>机器数——>有符号数：
  - 先将无符号数写成机器数（计算机内部存储形式）——简单
  - 再将该机器数解释为补码。

**2、不同字长整数之间的转换**

当大字长变量向小字长变量强转时，系统把多余的**高位字长部分直接截断，低位直接赋值**，也是一种保持位值的处理方式。

小字长变量转为大字长变量，不仅要使相应的位值相等，**高位部分还会扩展为原数字的符号位。**

例如char类型为8位ASCII码无符号整数，其转换为int时，在高位部分补0即可。



# 类型定义typedef

使程序更加易于理解和移植。

C语言库自身使用typedef为那些可能依据不同机器C语言实现的不同而不同的类型创建类型名，这些类型名常以_t结尾。如在C99中，int32_t为恰好占用32位的有符号整型。这种方式使得程序更易于移植。



# 符号常量和const常量

符号常量就是“替换”，用一个标识符来替换常量，又称“宏定义”

```
#define pi 3.14
```

注意：没有分号也没有逗号。

```
const常量：const double pi = 3.14;
```

以上两种都是常量的定义方法，一旦确定后就无法改变。



# sizeof运算符

sizeof（类型名）：表达式的值是一个无符号数，表示类型名的字节数。

sizeof也可以作用于常量、变量和表达式。此时原则上可以不加圆括号，但是由于运算符的优先级，最好还是加上。

显示sizeof值时要注意，sizeof表达式的类型是size_t，这是一种由实现定义的类型。在C89中，最好在显示前把表达式的值转换成一种已知的类型，再用printf显示。C99中printf可以直接显示size_t类型值，在转换说明中加z，如%zu。

