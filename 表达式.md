### 一、 算术运算符

一元运算符：正负号

二元运算符：加减乘除求余

运算符/可能产生意外的结果。当两个操作数都是整数时，运算符/会丢掉分数部分“截取”结果。%

%要求操作数必须是整数。如果有一个不是整数，程序将无法编译通过。

把零用作/或%的右操作数会导致未定义的行为。

当运算符/和%用于负操作数时，C89中其结果难以确定，在C99中除法的结果总是向零截取的。i%j的值的符号与i相同。



### 二、赋值运算符

> 注：在许多编程语言中，赋值是语句；而C语言中，赋值就像加法那样是一种运算符。赋值表达式a=b的值就是赋值运算后a的值。

变量的赋值会涉及到类型转换的问题。

赋值运算符都是右结合的，多个赋值可以串联在一起，按照右结合的规则执行。但注意由于存在类型转换的问题，串联赋值可能会因为精度丢失而导致最终结果不符合预期。

尽量不使用“嵌入式赋值”。不便于程序阅读且会产生隐含错误。

#### 左值与右值

左值是可以出现在赋值运算符左侧的表达式，右值是可以出现在赋值运算符右侧的表达式。

赋值运算要求它的左操作数必须是**左值(lvalue)**。左值表示存储在计算机内存中的对象，而不是常量或计算的结果（表达式）。变量是一种典型的左值。

#### 简单赋值（simple assignment）——“=”

副作用

通常我们不希望运算符修改它们的操作数，数学中的运算符就是如此。表达式i + j不会改变i，j的值，只是计算出i加j的结果。

大多数C语言运算符不会改变操作数的值，对于会改变操作数的值的运算符，称它们有副作用（side effect）。简单赋值运算符就是一个有副作用的运算符（改变了运算符的左操作数）。例如：i=0的结果为0，副作用是i的值变为0。



#### 复合赋值（compound assignment）

利用变量的原有值计算出新值并重新赋值给这个变量

+=

-=

*=

/=

%=

注意：v += e 并不是完全“等价于” v = v + e。



### 三、自增自减运算符

++和--运算符既可以作为前缀（prefix）运算符：++i；--i。立即自增自减

也可以作为后缀（postfix）运算符：i++；i--。稍后再自增自减。

注：这里的稍后应该在前一个顺序点和下一个顺序点之间更新操作数的值，C语言中有多种不同类型的顺序点，表达式语句的末尾是其中一种。在表达式语句的末尾，该语句中的所有自增和自减操作都必须执行完毕。

前缀自增的结果是i+1，后缀自增的结果是i

后缀自增自减运算符比一元的正负号优先级高，且都是左结合的。

前缀自增自减运算符与一元的正负号优先级相同，且都是右结合的。



### 四、表达式语句

C语言中任何表达式都可以用作语句。也就是说，**不论表达式是什么类型，计算什么结果，都能通过后面添加分号的方式将表达式转换成语句。**但是**会丢掉表达式的值**，如果表达式没有副作用，那么将表达式作为语句就没有任何意义。



### 五、编程题

1、编写一个程序，要求输入一个数，然后按数位的逆序打印出这个数。

- 使用算术分割法

```c
#include<stdio.h>
int main(){
	int num,temp;
    scanf("%d",&num);
    if(num == 0)
        printf("%d",num);
    while(num){
        temp = num%10;
        num /= 10;
        printf("%d",temp);
    }
    /*为了避免单独判断0的情况，可以使用do语句
    do{
        temp = num % 10;
        num /= 10;
        printf("%d",temp);
    }while(num);
    */
	getchar();getchar();
    return 0;
}
```

- 使用数位读取法

程序不是按n位数来读取用户输入的数，而是将它们读作n个一位数。把数看成一个独立的数字进行读取更为方便，而且也无需担心由于位数过大而无法存储到int型变量中。（某些编译器限定int型变量的最大值为32767）。

为了读取单个的数字，使用带有%1d转换说明的scanf函数，%1d匹配的只有一位整数。不过这种方式要事先知道数的位数。而且不能用循环，好蠢……

```c
#include<stdio.h>
int main(){
    int a[3],i；
    scanf("%1d%1d%1d",&a[0],&a[1],&a[2]);
    for(i=2;i>=0;i--)
    	printf("%d",a[i]);
    getchar();getchar();
    return 0;
}
```



2、编写一个程序，读入输入的整数，显示对应八进制数,二进制数。

算法思想：除余取整法——算术分割

把原始的数除以8，所得余数是八进制数的最后一位，然后把原始的数除以8，在对8取余，得到倒数第二位。

ps:这里有个问题，每次摘出来的是倒叙的，要输出顺序的数。这里我用了两种方法，也是借鉴回文数的思想：

①开辟一个数组，将分割出来的数顺序存放在数组中，然后逆序遍历数组输出。

②直接将每个数字组成一个逆序数，然后调用逆序输出函数（将前面的逆序输出一个数封装为一个函数），逆序的逆序就是顺序了。

但我总觉得这两种方法不是很好，首先①如果数位很多就会导致数字很大，int装不下。②也因为事先并不知道数的位数，无法准确确定申请的数组大小。

```c
#include<stdio.h>
//逆序输出
int reverse_print(int num){
	int temp;
	if(num == 0)
        printf("%d",num);
    while(num){
        temp = num%10;
        num /= 10;
        printf("%d",temp);
    }
    return 0;
}

//转八进制输出，使用②
int Octal(int num){
	int sum=0;
	do{
		sum = sum*10 + num % 8;
		num /= 8;
	}while(num);
	putchar('0');		//八进制数前缀标志
	reverse_print(sum);
	return 0;
}

//转二进制输出，使用①
int Binary(int num){
	int a[10]={0},i,temp;
	if(num == 0)
        printf("%d",num);
	for(i=0;num!=0;i++){
		temp = num % 2;
		num /= 2;
		a[i] = temp;
	}
	for(;i>0;i--)
		printf("%d",a[i-1]);
	return 0;
}
int main(){
	int num,sum=0;
	scanf("%d",&num);
	Octal(num);
	getchar();getchar();
	Binary(num);
	return 0;
}
```



3、通用产品代码（条形码）可以识别生成商和产品。每个条形码表示一个12位的数，包括三部分：第一个数表示商品种类、第一组5位数表示生产商、第二组5位数用来标识产品、最后一位数是“校验位”。

校验位的计算方法：

1、3、5、7、9、11位数字相加 = sum1

2、4、6、8、10位数字相加 = sum2

校验位 == 9 - [sum1 * 3 + sum2 - 1 ) % 10]

一次输入11位数，编程计算输出校验位。

算法思想：使用算术分割将每位数位剥离，分别存放在数组中。而后对数组进行操作。

```c
//当做数字输入
#include<stdio.h>
int main(){
    long long num,temp,a[11]={0},sum1=0,sum2=0;
    int i;
    scanf("%lld",&num);
    for(i=0;num!=0;i++){
        temp = num % 10;
        num /= 10;
        a[i] = temp;
    }
    for(i=0;i<11;i+=2)
        sum1 += a[i];
    for(i=1;i<11;i+=2)
        sum2 += a[i];
    }
    printf("%lld",9-(sum1*3+sum2-1)%10);
    return 0;
}

//当作字符读入
#include<stdio.h>
int main(){
    int i,sum1=0,sum2=0;
    int a[11]={0};
    for(i=0;i<11;i++){
        a[i] = getchar();
        a[i] -= 'a';	//a[i] -= 48;
    }
    for(i=0;i<11;i+=2)
        sum1 += a[i];
    for(i=1;i<11;i+=2)
        sum2 += a[i];
    printf("%d",9-(sum1*3+sum2-1)%10);
    return 0;
}

```

